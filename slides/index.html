<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Docker Driven Development</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/github.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section class="title" data-background="/images/docker.png" data-background-size="400px" data-background-opacity="0.2">
					<h1>Docker Driven Development</h1>
					<p class="center">Нужен ли Docker для разработки?</p>
				</section>
				<section>
					<h3>Эволюция процесса разработки</h3>
					<p class="center">на примере разработки сайтов на базе LAMP</p>
					<ol>
						<li class="fragment">Denwer, WAMP, XAMP</li>
						<li class="fragment">Виртуалка + FTP</li>
						<li class="fragment">Виртуалка + Samba</li>
						<li class="fragment">Linux как основная OS</li>
						<li class="fragment">Код на локальной машине + lsync (realsync)</li>
						<li class="fragment">Docker</li>
					</ol>
					<aside class="notes">
						Описание эволюции моего процесса разработки
					</aside>
				</section>
				<section>
					<h3>Эволюция процесса разработки</h3>
					<image data-src="/images/dev-matrix.png"></image>
				</section>
				<section>
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="fragment">
							<span>Версии ПО отличаются на проде и на компьютере разработчика</span>
							<ul>
								<li class="fragment">Сложность установки ПО</li>
								<li class="fragment">Нет нужной версии ПО под вашу OS</li>
							</ul>
						</li>
						<li class="fragment">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="fragment">Сложное развертывание проекта</li>
						<li class="fragment">Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes mini" data-markdown>
						# Недостатки стандартного подхода к разработке

						## Версии ПО отличаются на проде и на компьютере разработчика
						Средний разработчик часто не задумывается о необходимости совпадения версий ПО на проде и на своем компьютере. Допускаю, что он и не должен об этом задумываться. Это может быть проблемой его старших коллег. Однако для старших коллег соблюдение версий ПО приводит к внушительному вороху проблем.

						Почему это важно?
						Почему это происходит?

						## Нет нужной версии ПО под вашу OS
						Случается, что ПО недоступно для установки на конкретно вашу OS. 
						Придется установить виртуалку с нужной OS, а ПО устанавливать в виртуалку. Однако это не снимает проблему со сложностью установки.
						
						## Сложность установки ПО
						Уверен, что каждый из нас сталкивался со сложностями в установке ПО. Этого очень сложно избежать, потому что:
						1. Само ПО достаточно сложное.
						1. Оно зависит от другого ПО.
						1. Оно может быть несовместимо с уже установленным ПО.
						1. Инструкции по установке неточны.
						
						Вышеозначенные причины могут привести к таким вариантам:
						1. Придется потратить много времени на установку.
						1. Придется пригласить админа, который в состоянии помочь в установке конкретного ПО.
						1. Установка будет невозможна.
						
						## Сложное развертывание проекта
						При развитии проекта очень часто нужно вводить нового разработчика в проект. И тут сразу возникают сложности:
						1. Для развертывания сложного проекта требуются сложные инструкции.
						1. Сложная инструкция требует много времени для разработки. Причем это время должен потратить один из самых опытных разработчиков.
						1. Если инструкция все таки написана, то само развертывание проекта для нового разработчика все равно представляет собой сложную задачу. 
						1. Каждое развертывание занимает много времени.
						
						Проблема зачастую заключается в том, что в такого рода инструкциях очень много шагов.
						Ошибка на любом этапе приводит к невозможности установки.
						Для выполнения даже самых простых задач на таком проекте требуется потратить очень много времени.
						Частая ситуация: нужно _покрасить_ кнопочку или внести другие схожие изменения. Эта работа обычно занимает 15-30 минут времени. Причем эту работу в состоянии выполнить и junior. А на развертывание проекта легко уходит от одного часа и более. Причем квалификация человека, который разворачивает проект, должна быть выше квалификации конечного исполнителя. Простейшая задача становится дорогой. А такие затраты сложно объяснить заказчику. 
						
						В итоге возможны варианты:
						1. Задачу будет исполнять специалист, у которого уже развернут этот проект. И это все равно приведет к проблемам:
								- это будет сделано только тогда, когда у него появится на это время;
								- простая задача должна быть исполнена дорогим специалистом.
						1. В проект привлечен новый специалист, но потрачено огромное количество времени на его привлечение.
						1. Задача может быть не выполнена вообще.
						
						## Очень сложно исполнять один и тот же код с разными версиями ПО или с разными настройками
						Зачем это вообще может понадобиться?
						Мне в голову приходят следующие варианты:
						1. Тестирование проекта в различных окружениях. Например планируется переход на новую версию серверного ПО или новую версию интерпретатора (компилятора).
						1. Тестирование продуктов собственной разработки в различных окружениях. Например у клиентов ваше ПО используется в различных окружениях. Для поставки качественного продукта вам необходимо свое ПО тестировать в окружении __идентичном__ окружению клиента.
						1. Тестирование библиотеки собственной разработки. Вы поставляете на рынок библиотеку, а клиенты используют ее в каких-то очень __специфических__ окружениях.
						
						Все эти проблемы решаются с помощью виртуалок. Но процесс развертывания достаточно долгий. А хранение и перенос виртуалок между разработчиками может быть затруднен.
						
						## Устанавливаемое ПО засоряет компьютер разработчика
						Установленное ПО занимает не только место на диске, но и зачастую запускает дополнительные процессы в системе. Таким образом съедаются процессорные мощности вашего компьютера.
						Если для установленного ПО выходят обновления, то вы их скачиваете без особой на то надобности. Сразу вспоминается Skype, который в последнее время обновляется чуть ли не ежедневно.
					</aside>
				</section>
				<section>
					<h2>Docker</h2>
					<h3 class="fragment bright">решает</h3>
					<p class="fragment center">все эти проблемы</p>
					<p class="fragment center">и даже больше</p>
				</section>
				<section class="intro" data-background="/images/docker.png" data-background-size="800px" data-background-opacity="0.5">
					<h2>Введение</h2>
				</section>
				<section data-transition="none">
					<h3>Образ и контейнер</h3>
					<ul>
						<li class="fragment">Образ и контейнер</li>
						<li class="fragment">
							<span>
								Распространение образов
							</span>
							<ul>
								<li class="fragment">Официальные образы</li>
								<li class="fragment">Кастомные образы на Docker Hub</li>
								<li class="fragment">Кастомные образы в приватном Docker Registry</li>
							</ul>
						</li>
					</ul>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Запуск контейнера (docker run)
						```bash
						docker run -d \
							-p 27017:27017 
							--volume=./data/mongo:/db/data \
							mongo:3-stretch
						```
						<aside class="notes" data-markdown>
							- -d
							- Порты
							- Тома
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Dockerfile
						```yaml
						FROM mongo:3-stretch

						COPY ./mongo.conf /usr/local/etc/mongo/mongo.conf
						EXPOSE 27017
						
						CMD ["mongod"]						
						```
						<aside class="notes mini" data-markdown>
							- Начальный образ
							- Указать на конкретную версию (тегирование)
							- Копирование
							- EXPOSE
							- CMD
							- указать на слои (одна строка = один слой)
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
								restart: always
						```
						<aside class="notes mini" data-markdown>
						</aside>
					</textarea>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
								restart: always
							
							rabbitmq:
								image: rabbitmq:3.7
								volumes:
									- ./data/rabbitmq:/var/lib/rabbitmq
								restart: always
						
							redis:
								image: redis
								command: ["redis-server", "--appendonly", "yes"]
						```
						<aside class="notes mini" data-markdown>
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						#### Структура папок
						```bash
						|-- containers
						|   |-- apache
						|   |   |-- rootfs
						|   |   |   `-- etc
						|   |   `-- Dockerfile
						|   `-- mysql
						|       |-- rootfs
						|       |   `-- etc
						|       `-- Dockerfile
						|-- data
						|   |-- mongodb
						|   |-- mysql
						|   `-- redis
						|-- logs
						|   |-- apache
						|   |-- mongodb
						|   |-- mysql
						|   `-- redis
						|-- src
						|   |-- service1
						|   |-- service2
						|   `-- service3
						`-- docker-compose.yml
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Структура файлов для описания контейнера
						```bash
						|-- apache2
						|   |-- rootfs
						|   |   `-- etc
						|   |       |-- apache2
						|   |       |   |-- conf-available
						|   |       |   |   `-- remoteip.conf
						|   |       |   |-- mods-available
						|   |       |   |   `-- remoteip.conf
						|   |       |   `-- sites-available
						|   |       |       |-- 000-default.conf
						|   |       |       `-- default-ssl.conf
						|   |       `-- php
						|   |           `-- 7.2
						|   |               |-- apache2
						|   |               |   `-- php.ini
						|   |               `-- cli
						|   |                   `-- php.in
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Dockerfile
						```yaml
						FROM php:7.2-apache

						COPY ./rootfs /
						```
					</textarea>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Установка БД
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup:/backup
								restart: always
						```
						<aside class="notes mini" data-markdown>
							## Описание проблемы 
							Первой проблемой, которая меня подтолкнула к контейнерам была невозможность 
							установки конкретной версии MySQL на свой компьютер. Проблема заключалась в том,
							что у меня уже стояла одна из предыдущих версий и отказываться от нее не входило в мои планы.
							
							## Решение
							Устанавливаем БД в контейнере.
							
							1. Берем готовый образ из Docker Hub.
							1. Указываем порт, который будет доступен на локальном компьютере.
							1. Монтируем том, который будет содержать данные.
							1. Остается только развернуть БД из бэкапа

							docker exec -it db sh -c "mysql -u root -p db < /backup/db.sql"

							Конкретно для mysql есть вариант первоначального восстановления из бэкапа проще. 
							Но он не рассмотрен для простоты.
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Восстановление БД из backup

						```bash
						docker exec -it db sh -c "mysql -u root -p db < /backup/db.sql"
						```
						<aside class="notes" data-markdown>
							Команда довольно простая и она будет одинаковой для всех проектов, которые используют подобную схему.
							Идеальным вариантом будет использование утилиты `make`. Тогда один раз написанный `Makefile` можно распространить на все проекты.
						</aside>
					</textarea>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li>Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section>
					<h3>Версии ПО или разные настройки</h3>
					<ul>
						<li class="fragment">Тестирование проекта в различных окружениях.</li>
						<li class="fragment">Тестирование продуктов собственной разработки в различных окружениях.</li>
						<li class="fragment">Подключение дебаггера.</li>
						<li class="fragment">Компиляция проекта разными версиями.</li>
					</ul>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Запуск простого проекта на локальном компьютере
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html
						```
					</textarea>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Тестирование проекта в различных окружениях
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html

							server73:
								image: php:7.3-apache
								ports:
									- 8073:80
								volumes:
									- ./src:/var/www/html
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера 
						#### docker-compose.yml
						```yaml
						version: '2'
				
						services:
							server:
								build: apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера
						#### Dockerfile
						```yaml
						FROM php:7.2-apache
						
						RUN DEBIAN_FRONTEND=noninteractive apt-get -y install \
							php7.2-xdebug
											
						COPY ./rootfs /
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера
						#### Измененный ini файл
						```bash
						cat ./containers/apache2/rootfs/etc/php/7.2/apache2/php.ini | grep xdebug
						```
						```ini
						[xdebug]
						xdebug.remote_host = "172.19.0.1"
						xdebug.remote_port = 9000
						xdebug.remote_autostart = 1
						xdebug.remote_enable = 1
						```
						<aside class="notes" data-markdown>
							Следует отметить, что IP адрес может изменяться.
							Стоит IP адрес передавать через переменные окружения.
							Cистема становится несколько сложнее и для демонстрации эти возможности опущены.
						</aside>
					</textarea>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Сложное развертывание проекта
					</textarea>
				</section>
				
				<section data-markdown class="size-xs">
					<textarea data-template>
						### Сложное развертывание проекта

						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								container_name: db
								ports:
									- 3306:3306
								environment:
									MYSQL_DATABASE: db
									MYSQL_USER: my_user
									MYSQL_PASSWORD: 123
									MYSQL_ROOT_PASSWORD: 123
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup/mysql:/bakup
								restart: always
							
							rabbitmq:
								image: rabbitmq:3.7
								volumes:
									- ./data/rabbitmq:/var/lib/rabbitmq
								restart: always
						
							redis:
								image: redis
								command: ["redis-server", "--appendonly", "yes"]
						```
						<aside class="notes" data-markdown>
							При стандартном подходе к разворачиванию ПО сложность растет в геометрической прогрессии от числа элементов.

							При использовании докера сложность растет линейно.
						</aside>
					</textarea>
				</section>				
				<section data-markdown class="mini">
					<textarea data-template>
						### Сложное развертывание проекта
						#### Makefile
						```
						#!/usr/bin/make
						
						.PHONY : help init backup restore
						
						.DEFAULT_GOAL := help
						
						init: download restore
						
						download:
							@echo "start downloading database"
							scp user@example.com:/path/to/backup/db.sql ./backup/mysql/db.sql

						restore:
							@echo "start restoring database"
							docker exec -it db sh -c "mysql -u root -p123 db < /backup/db.sql"
						```
						<aside class="notes" data-markdown>
							Еще больше упростить можно с помощью утилиты make
						</aside>
					</textarea>
				</section>		
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>						
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section>
					<h3>Устанавливаемое ПО засоряет компьютер разработчика</h3>
					<ul>
						<li class="fragment">Только запущенный контейнер потребляет память и CPU</li>
						<li class="fragment">Образ состоит из слоев</li>
						<li class="fragment">От устаревших образов и отдельных слоев можно и нужно избавляться</li>
					</ul>
					<aside class="notes" data-markdown>
						## Слоистая структура образов
						Каждый образ состоит из нескольких слоев. Слой создает каждая из команд внутри `Dockerfile`. Такой подход обеспечивает переиспользование слоя и экономит место на диске и ускоряет время сборки образа.
						При повторной сборке образа учитываются изменения в `Dockerfile` и изменения в файлах, которые участвуют в сборке.
						Если изменений в `Dockerfile` не было, то образ _соберется_ очень быстро.
						Чем выше в `Dockerfile` были изменения тем больше слоев нужно пересобирать. То есть часто изменяемые настройки следует помещать ближе к концу `Dockerfile`.
						
						## Устаревшие образы продолжают занимать место
						В процессе работы с docker может сильно замусориваться файловая система устаревшими образами и устаревшими слоями. Для того, чтобы этого избежать необходимо чистить файловую систему от неиспользуемых образов. Сделать это можно командой:
						```
						docker system prune
						```
						
						Однако это не всегда решает всех проблем, поэтому стоит изучить этот вопрос поподробнее. Или просто купить SSD побольше.				</section>
					</aside>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Чистка устаревших образов
						```
						docker system prune
						```
					</textarea>						
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li class="strike">Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section>
					<h3>Еще примеры</h3>
					<ol>
						<li>Переключение между пользователями</li>
						<li>Тестирование с использованием БД</li>
						<li>Переключение между состояниями БД</li>
						<li>Тестирование с использованием mock сервиса</li>
					</ol>
				</section>				
				<section>
					<h3>Переключение между пользователями</h3>
					<ul>
						<li class="fragment">Сложная логика работы с пользователями.</li>
						<li class="fragment">Пользователи с разными ролями.</li>
						<li class="fragment">Необходимость использования одинаковых средств отладки.</li>
					</ul>
				</section>
				<section>
						<h2>Тестирование с использованием БД</h2>
						<ol>
							<li class="fragment">Ручное тестирование скриптов</li>
							<li class="fragment">Ручное тестирование функционала</li>
							<li class="fragment">
								<span>Unit тестирование</span>
								<ul>
									<li class="fragment bright">Лучше не надо</li>
									<li class="fragment">Но если очень хочется...</li>
								</ul>
							</li>
						</ol>					
					</section>
					<section data-markdown>
						<textarea data-template>
							#### Стандартный подход к тестированию с использованием БД
							1. Создать БД и наполнить БД нужными данными, либо восстановить ее из бэкапа.
							1. Выполнить тесты.
							1. Удалить или очистить БД.
						</textarea>
					</section>
					<section data-markdown>
						<textarea data-template>
							#### Современый подход к тестированию с использованием БД
							1. Создать __один раз__ контейнер содержащий БД.
							1. Запускаем контейнер.
							1. Запускаем тесты.
							1. Останавливаем контейнер.						
						</textarea>
					</section>
	
				<section>
					<h3>Тестирование с использованием mock-сервиса</h3>
				</section>
				<section>
					<h3>Дополнительные вопросы</h3>
					<ul>
						<li class="fragment">Пользователь в Dockerfile</li>
						<li class="fragment">Переменные среды</li>
						<li class="fragment">Документирование (Инфраструктура как код)</li>
						<li class="fragment">Использование Docker в Windows и MacOS</li>
						<li class="fragment">Запуск сервиса внутри контейнера (docker-compose run)</li>
					</ul>
				</section>
				<section>
					<h3>Выводы</h3>
					<ul>
						<li class="fragment">Docker - просто начать</li>
						<li class="fragment">Docker - большие возможности</li>
					</ul>
				</section>
				<section>
						<h1><span>Resume</span><span class="fragment"> driven</span><span class="fragment"> development</span> <span class="fragment bright"> completed!</span></h1>
				</section>
				<section class="thanks" data-background="/images/friends.png" data-background-size="600px">
					<h3>Спасибо!</h3>
					<h3>Вопросы?</h3>
					<p>Андрей Копылов</p>
					<p>aa74ko@gmail.com</p>
					<p>https://github.com/aak74/docker-driven-development</p>
					<br />
					<strong>
						<p>Мы нанимаем:</p>
						<p>job@arealidea.ru</p>
					</strong>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
				]
			});
			Reveal.configure({ slideNumber: true });
		</script>
	</body>
</html>
