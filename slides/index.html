<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Docker Driven Development</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/github.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section class="title" data-background="/images/docker.png" data-background-size="400px" data-background-opacity="0.2">
					<h1>Docker Driven Development</h1>
					<p class="center">Нужен ли Docker для разработки?</p>
					<aside class="notes">
						<p>Бытует мнение, что docker сложен и нужен только для использования на проде. И даже там он нужен только корпорациям. </p>
						<p>Я попробую доказать, что docker может и должен использоваться в процессе разработки на компьютерах разработчиков. Это утверждение верно даже если на проде у вас нет и не будет docker-а.</p>
					</aside>
				</section>
				<section class="about">
					<h2>About</h2>
					<p class="me">Андрей Копылов</p>
					<ul>
						<li>Технический директор AREALIDEA</li>
						<li>В веб-разработке с 2006</li>
					</ul>
					<p>aa74ko@gmail.com</p>
				</section>
				<section>
					<h3>Эволюция процесса разработки</h3>
					<p class="center">на примере разработки сайтов на базе LAMP</p>
					<ol>
						<li class="fragment">Denwer, WAMP, XAMP</li>
						<li class="fragment">Виртуалка + FTP</li>
						<li class="fragment">Виртуалка + Samba</li>
						<li class="fragment">Linux как основная OS</li>
						<li class="fragment">Код на локальной машине + lsync (realsync)</li>
						<li class="fragment">Docker</li>
					</ol>
					<aside class="notes">
						Описание эволюции моего процесса разработки
					</aside>
				</section>
				<section>
					<h3>Эволюция процесса разработки</h3>
					<image data-src="/images/dev-matrix.png"></image>
				</section>
				<section>
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="fragment">
							<span>Версии ПО отличаются на проде и на компьютере разработчика</span>
							<ul>
								<li class="fragment">Сложность установки ПО</li>
								<li class="fragment">Нет нужной версии ПО под вашу OS</li>
							</ul>
						</li>
						<li class="fragment">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="fragment">Сложное развертывание проекта</li>
						<li class="fragment">Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes mini" data-markdown>
						# Недостатки стандартного подхода к разработке

						## Версии ПО отличаются на проде и на компьютере разработчика
						Средний разработчик часто не задумывается о необходимости совпадения версий ПО на проде и на своем компьютере. Допускаю, что он и не должен об этом задумываться. Это может быть проблемой его старших коллег. Однако для старших коллег соблюдение версий ПО приводит к внушительному вороху проблем.

						Почему это происходит?

						## Сложность установки ПО
						Уверен, что каждый из нас сталкивался со сложностями в установке ПО. Этого очень сложно избежать, потому что:
						1. Само ПО достаточно сложное.
						1. Оно зависит от другого ПО.
						1. Оно может быть несовместимо с уже установленным ПО.
						1. Инструкции по установке неточны.
						
						Вышеозначенные причины могут привести к таким вариантам:
						1. Придется потратить много времени на установку.
						1. Придется пригласить админа, который в состоянии помочь в установке конкретного ПО.
						1. Установка будет невозможна.
						## Нет нужной версии ПО под вашу OS
						Случается, что ПО недоступно для установки на конкретно вашу OS. 
						Придется установить виртуалку с нужной OS, а ПО устанавливать в виртуалку. Однако это не снимает проблему со сложностью установки.
						
						## Очень сложно исполнять один и тот же код с разными версиями ПО или с разными настройками
						Зачем это вообще может понадобиться?
						Мне в голову приходят следующие варианты:
						1. Тестирование проекта в различных окружениях. Например планируется переход на новую версию серверного ПО или новую версию интерпретатора (компилятора).
						1. Тестирование продуктов собственной разработки в различных окружениях. Например у клиентов ваше ПО используется в различных окружениях. Для поставки качественного продукта вам необходимо свое ПО тестировать в окружении __идентичном__ окружению клиента.
						1. Тестирование библиотеки собственной разработки. Вы поставляете на рынок библиотеку, а клиенты используют ее в каких-то очень __специфических__ окружениях.
						
						Все эти проблемы решаются с помощью виртуалок. Но процесс развертывания достаточно долгий. А хранение и перенос виртуалок между разработчиками может быть затруднен.
						
						## Устанавливаемое ПО засоряет компьютер разработчика
						Установленное ПО занимает не только место на диске, но и зачастую запускает дополнительные процессы в системе. Таким образом съедаются процессорные мощности вашего компьютера.
						Если для установленного ПО выходят обновления, то вы их скачиваете без особой на то надобности. Сразу вспоминается Skype, который в последнее время обновляется чуть ли не ежедневно.

						## Сложное развертывание проекта
						При развитии проекта очень часто нужно вводить нового разработчика в проект. И тут сразу возникают сложности:
						1. Для развертывания сложного проекта требуются сложные инструкции.
						1. Сложная инструкция требует много времени для разработки. Причем это время должен потратить один из самых опытных разработчиков.
						1. Если инструкция все таки написана, то само развертывание проекта для нового разработчика все равно представляет собой сложную задачу. 
						1. Каждое развертывание занимает много времени.
						
						Проблема зачастую заключается в том, что в такого рода инструкциях очень много шагов.
						Ошибка на любом этапе приводит к невозможности установки.
						Для выполнения даже самых простых задач на таком проекте требуется потратить очень много времени.
						Частая ситуация: нужно _покрасить_ кнопочку или внести другие схожие изменения. Эта работа обычно занимает 15-30 минут времени. Причем эту работу в состоянии выполнить и junior. А на развертывание проекта легко уходит от одного часа и более. Причем квалификация человека, который разворачивает проект, должна быть выше квалификации конечного исполнителя. Простейшая задача становится дорогой. А такие затраты сложно объяснить заказчику. 
						
						В итоге возможны варианты:
						1. Задачу будет исполнять специалист, у которого уже развернут этот проект. И это все равно приведет к проблемам:
								- это будет сделано только тогда, когда у него появится на это время;
								- простая задача должна быть исполнена дорогим специалистом.
						1. В проект привлечен новый специалист, но потрачено огромное количество времени на его привлечение.
						1. Задача может быть не выполнена вообще.
					</aside>
				</section>
				<section>
					<h2>Docker <span class="bright">решает</span></h2>
					<div class="fragment center">
						<p>все эти проблемы</p>
						<p>и даже больше</p>
					</div>
				</section>
				<section class="intro" data-background="/images/docker.png" data-background-size="800px" data-background-opacity="0.5">
					<h2>Введение</h2>
				</section>
				<section data-transition="none">
					<h3>Введение</h3>
					<ul>
						<li class="fragment">Образ и контейнер</li>
						<li class="fragment">
							<span>
								Распространение образов
							</span>
							<ul>
								<li class="fragment">Официальные образы</li>
								<li class="fragment">Кастомные образы на Docker Hub</li>
								<li class="fragment">Кастомные образы в приватном Docker Registry</li>
							</ul>
						</li>
					</ul>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Запуск контейнера (docker run)
						```bash
						docker run -d \
							-p 27017:27017 
							--volume=./data/mongo:/db/data \
							mongo:3-stretch
						```
						<aside class="notes" data-markdown>
							- -d
							- Порты
							- Тома
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Dockerfile
						```yaml
						FROM mongo:3-stretch

						COPY ./mongo.conf /usr/local/etc/mongo/mongo.conf
						```
						<aside class="notes mini" data-markdown>
							- Начальный образ
							- Указать на конкретную версию (тегирование)
							- Копирование
							- EXPOSE
							- CMD
							- указать на слои (одна строка = один слой)
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
								restart: always
						```
						<aside class="notes mini" data-markdown>
						</aside>
					</textarea>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
								restart: always
							
							rabbitmq:
								image: rabbitmq:3.7
								volumes:
									- ./data/rabbitmq:/var/lib/rabbitmq
								restart: always
						
							redis:
								image: redis
								command: ["redis-server", "--appendonly", "yes"]
						```
						<aside class="notes mini" data-markdown>
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						#### Структура папок
						```bash
						|-- containers
						|   |-- apache
						|   |   |-- rootfs
						|   |   |   `-- etc
						|   |   `-- Dockerfile
						|   `-- mysql
						|       |-- rootfs
						|       |   `-- etc
						|       `-- Dockerfile
						|-- data
						|   |-- mongodb
						|   |-- mysql
						|   `-- redis
						|-- logs
						|   |-- apache
						|   |-- mongodb
						|   |-- mysql
						|   `-- redis
						|-- src
						|   |-- service1
						|   |-- service2
						|   `-- service3
						|   Makefile
						`-- docker-compose.yml
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Структура файлов для описания контейнера
						```bash
						|-- apache2
						|   |-- rootfs
						|   |   `-- etc
						|   |       |-- apache2
						|   |       |   |-- conf-available
						|   |       |   |   `-- remoteip.conf
						|   |       |   |-- mods-available
						|   |       |   |   `-- remoteip.conf
						|   |       |   `-- sites-available
						|   |       |       |-- 000-default.conf
						|   |       |       `-- default-ssl.conf
						|   |       `-- php
						|   |           `-- 7.2
						|   |               |-- apache2
						|   |               |   `-- php.ini
						|   |               `-- cli
						|   |                   `-- php.ini
						|   `-- Dockerfile
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Dockerfile
						```yaml
						FROM php:7.2-apache

						COPY ./rootfs /
						```
					</textarea>
				</section>
				<section>
					<h2>Решение проблем</h2>
					<ol>
						<li>Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Установка БД
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup:/backup
								restart: always
						```
						<aside class="notes mini" data-markdown>
							## Описание проблемы 
							Первой проблемой, которая меня подтолкнула к контейнерам была невозможность 
							установки конкретной версии MySQL на свой компьютер. Проблема заключалась в том,
							что у меня уже стояла одна из предыдущих версий и отказываться от нее не входило в мои планы.
							
							## Решение
							Устанавливаем БД в контейнере.
							
							1. Берем готовый образ из Docker Hub.
							1. Указываем порт, который будет доступен на локальном компьютере.
							1. Монтируем том, который будет содержать данные.
							1. Остается только развернуть БД из бэкапа
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Восстановление БД из backup

						```bash
						docker exec -it mysql sh -c "mysql -u root -p db < /backup/db.sql"
						```
						<aside class="notes" data-markdown>
							Команда довольно простая и она будет одинаковой для всех проектов, которые используют подобную схему.
							Конкретно для mysql есть вариант первоначального восстановления из бэкапа проще. 
							Но он не рассмотрен для простоты.
							Идеальным вариантом будет использование утилиты `make`. Тогда один раз написанный `Makefile` можно распространить на все проекты.
						</aside>
					</textarea>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li>Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section>
					<h3>Версии ПО или разные настройки</h3>
					<ul>
						<li class="fragment">Тестирование проекта в различных окружениях.</li>
						<li class="fragment">Тестирование продуктов собственной разработки в различных окружениях.</li>
						<li class="fragment">Подключение дебаггера.</li>
						<li class="fragment">Компиляция проекта разными версиями.</li>
					</ul>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Запуск простого проекта на локальном компьютере
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes">
							Для начала рассмотрим запуск простейшего проекта
						</aside>
					</textarea>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Тестирование проекта в различных окружениях
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html

							server73:
								image: php:7.3-apache
								ports:
									- 8073:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes">
							- На другой порт цепляем другую версию ПО.
							- Том оставляем тот же самый
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера 
						#### docker-compose.yml
						```yaml
						version: '2'
				
						services:
							server:
								build: ./containers/apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes">
							Для подключения дебаггера нужно поменять docker-compose.yml
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера
						#### Dockerfile
						```yaml
						FROM php:7.2-apache
						
						RUN DEBIAN_FRONTEND=noninteractive apt-get -y install \
							php7.2-xdebug
											
						COPY ./rootfs /
						```
						<aside class="notes">
							Добавить описание контейнера
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера
						#### Измененный ini файл
						```bash
						cat ./containers/apache2/rootfs/etc/php/7.2/apache2/php.ini | grep xdebug
						```
						```ini
						[xdebug]
						xdebug.remote_host = "172.19.0.1"
						xdebug.remote_port = 9000
						xdebug.remote_autostart = 1
						xdebug.remote_enable = 1
						```
						<aside class="notes" data-markdown>
							Изменить настройки.

							Следует отметить, что IP адрес может изменяться.
							Стоит IP адрес передавать через переменные окружения.
							Cистема становится несколько сложнее и для демонстрации эти возможности опущены.
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Компиляция кода конкретной версией компилятора

						#### docker-compose.yml
						```yaml
						version: '3'
						services:
							compile:
								image: golang:1.11-alpine
								volumes:
									- ./src:/go
								working_dir: /go						
						```

						#### Компиляция
						```bash
						docker-compose run --rm compile go build -o main
						```
						<aside class="notes" data-markdown>
						</aside>
					</textarea>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section>
					<h3>Сложное развертывание проекта</h3>
					<ul>
						<li class="fragment">Установить MySQL версии 5.7.23</li>
						<li class="fragment">Установить RabbitMQ 3.7.7</li>
						<li class="fragment">Установить Redis 4.0.8</li>
						<li class="fragment">Сделать дамп БД на сервере ...</li>
						<li class="fragment">Восстановить БД из полученного дампа на сервере ...</li>
					</ul>
				</section>
				
				<section data-markdown class="size-xs">
					<textarea data-template>
						### Сложное развертывание проекта

						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:5.7.23
								container_name: db
								ports:
									- 3306:3306
								environment:
									MYSQL_DATABASE: db
									MYSQL_USER: my_user
									MYSQL_PASSWORD: 123
									MYSQL_ROOT_PASSWORD: 123
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup/mysql:/bakup
								restart: always
							
							rabbitmq:
								image: rabbitmq:3.7.7
								ports:
									- 5672:5672
								volumes:
									- ./data/rabbitmq:/var/lib/rabbitmq
								restart: always
						
							redis:
								image: redis:4.0.8
								command: ["redis-server", "--appendonly", "yes"]
						```
						<aside class="notes" data-markdown>
							- При стандартном подходе к разворачиванию ПО сложность растет в геометрической прогрессии от числа элементов.
							- При использовании докера сложность растет линейно.
							- Причем эта сложность существует только для специалиста, который описывает систему.
						</aside>
					</textarea>
				</section>				
				<section data-markdown class="mini">
					<textarea data-template>
						### Сложное развертывание проекта
						#### Makefile
						```
						...

						init: download restore
						
						download:
							@echo "Starting download database"
							scp user@example.com:/path/to/backup/db.sql ./backup/mysql/db.sql

						restore:
							@echo "Starting restore database"
							docker exec -it db sh -c "mysql -u root -p123 db < /backup/db.sql"
						```
						<aside class="notes" data-markdown>
							Еще больше упростить можно с помощью утилиты make.
							В последнее время я существенно подсел на эту волшебную утилиту.
						</aside>
					</textarea>
				</section>		
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>						
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes">
						Закрываем очередной недостаток
					</aside>
				</section>
				<section>
					<h3>Устанавливаемое ПО засоряет компьютер разработчика</h3>
					<ul>
						<li class="fragment">Только запущенный контейнер потребляет память и CPU</li>
						<li class="fragment">Образ состоит из слоев</li>
						<li class="fragment">От устаревших образов и отдельных слоев можно и нужно избавляться</li>
					</ul>
					<aside class="notes" data-markdown>
						## Слоистая структура образов
						Каждый образ состоит из нескольких слоев. Слой создает каждая из команд внутри `Dockerfile`. Такой подход обеспечивает переиспользование слоя и экономит место на диске и ускоряет время сборки образа.
						При повторной сборке образа учитываются изменения в `Dockerfile` и изменения в файлах, которые участвуют в сборке.
						Если изменений в `Dockerfile` не было, то образ _соберется_ очень быстро.
						Чем выше в `Dockerfile` были изменения тем больше слоев нужно пересобирать. То есть часто изменяемые настройки следует помещать ближе к концу `Dockerfile`.
					</aside>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Чистка устаревших образов
						```
						docker system prune
						```
						<aside class="notes" data-markdown>
							## Устаревшие образы продолжают занимать место
							В процессе работы с docker может сильно замусориваться файловая система устаревшими образами и устаревшими слоями. Для того, чтобы этого избежать необходимо чистить файловую систему от неиспользуемых образов. Сделать это можно командой:
							
							Однако это не всегда решает всех проблем, поэтому стоит изучить этот вопрос поподробнее. Или просто купить SSD побольше.				</section>
						</aside>
					</textarea>						
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li class="strike">Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section>
					<h2>Еще примеры</h2>
				</section>				
				<section>
					<h2>Тестирование с использованием БД</h2>
					<ol>
						<li class="fragment">Ручное тестирование скриптов</li>
						<li class="fragment">Ручное тестирование функционала</li>
						<li class="fragment">
							<span>Unit тестирование</span>
							<ul>
								<li class="fragment bright">Лучше не надо</li>
								<li class="fragment">Но если очень хочется...</li>
							</ul>
						</li>
					</ol>					
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Стандартный подход к тестированию с использованием БД
						1. Восстановление БД из бэкапа.
						1. Выполнить тесты.
						1. Удалить или очистить БД.
						<aside class="notes">
							<p>Если БД достаточно большая, то и восстанавливаться она будет долго.</p>
							<p>Этот процесс нужно выполнять при каждом тестировании.</p>
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Использование docker для тестирования с использованием БД
						1. Создать __один раз__ образ содержащий БД.
						1. Запускаем контейнер.
						1. Запускаем тесты.
						1. Останавливаем контейнер.						
						<aside class="notes">
							<p>Настойчиво обращаю внимание на то, что образ нужно подготовить один раз.</p>
							<p>В идеале такой образ хранится в docker registry и в вашем проекте будет автоматически использоваться нужная версия БД для тестирования</p>
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Использование docker для тестирования с использованием БД

						##### Dockerfile

						```yaml
						FROM mysql:8

						COPY ./db.sql /backup/

						RUN mysql -u root -p db < /backup/db.sql \
							&& rm /backup/db.sql
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Использование docker для тестирования с использованием БД

						##### build

						```bash
						docker build \
							--rm -f ./Dockerfile \
							-t test/db:0.1 .
						```

						##### Dockerfile
						```yaml
						FROM test/db:0.1
						```
					</textarea>
				</section>
				<section>
					<h3>Переключение между пользователями</h3>
					<ul>
						<li class="fragment">Сложная логика работы с пользователями.</li>
						<li class="fragment">Пользователи с разными ролями.</li>
						<li class="fragment">Необходимость использования одинаковых средств отладки.</li>
					</ul>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Переключение между пользователями
						#### docker-compose.yml
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 8080:80
								volumes:
									- ./src:/var/www/html
							server1:
								image: php:7.2-apache
								ports:
									- 8081:80
								volumes:
									- ./src:/var/www/html
							server2:
								image: php:7.2-apache
								ports:
									- 8082:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes">
							Достаточно размножить сервис и раскидать по различным портам и вы получаете нужное количество сессий в одном браузере
						</aside>
					</textarea>
				</section>
				<section>
					<h2>Дополнительные вопросы</h2>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Пользователь в Dockerfile

						##### Dockerfile
						```yaml
						FROM php:7.2-apache

						RUN usermod -u 1000 www-data
						```

						```yaml
						FROM php:7.2-cli

						USER 1000
						```
						<aside class="notes">
							<p>Если специальным образом не указать пользователя, под которым будут работать процессы в контейнере, то все процессы будут работать из под рута. Это неприемлемо с точки зрения безопасности.</p>
							<p>В процессе разработки можно упростить себе жизнь не указывая пользователя, но на проде это совершенно недопустимо. Но даже в процессе разработки я не рекомендую малодушничать. Всегда указывайте пользователя, под которым будут работать процессы в контейнере.</p>
							<p>Замена user id для процесса, запущенного под конкретным пользователем</p>
							<p>Замена user id текущего пользователя</p>
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Переменные среды

						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								container_name: db
								ports:
									- 3306:3306
								environment:
									MYSQL_DATABASE: ${DATABASE}
									MYSQL_USER: ${USER}
									MYSQL_PASSWORD: ${PASSWORD}
									MYSQL_ROOT_PASSWORD: ${ROOT_PASSWORD}
								volumes:
									- ./data/mysql1:/var/lib/mysq1
							```
						<aside class="notes">
							рассказать про .env и environment в docker-compose.yml
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Переменные среды

						#### .env
						```ini
						DATABASE=db
						USER=user
						PASSWORD=123
						ROOT_PASSWORD=123
						```
						<aside class="notes">
							<p>рассказать про .env и environment в docker-compose.yml</p>
							<p></p>пересборка образа обязательна.</p>
						</aside>
					</textarea>
				</section>
				<section class="size-s">
					<h3>Документирование (Инфраструктура как код)</h3>
					<ul>
						<li class="fragment">Dockerfile</li>
						<li class="fragment">docker-compose.yml</li>
						<li class="fragment">Makefile</li>
					</ul>
					<p class="fragment">Лучшая документация лежит рядом с кодом.</p>
					<aside class="notes">
						<h3>Dockerfile, docker-compose.yml, Makefile</h3>
						<p>Лучшая документация та, которая лежит рядом с кодом.</p>
						<p>
							Добавление в проект `Dockerfile` и `docker-compose.yml` описывают серверное окружение, в котором проект должен работать. Кроме быстрого развертывания это приносит дополнительную пользу. А именно документирование проекта. Информация о необходимом окружении будет весьма полезна даже если docker в проде не будет использоваться.
						</p>
					</aside>
				</section>
				<section>
					<h3>Использование Docker в Windows и MacOS</h3>
					<ul>
						<li class="fragment">Linux лучшая система для разработчика.</li>
						<li class="fragment">В других системах есть особенности.</li>
					</ul>
					<div class="fragment">
						<span>Но я про них ничего не знаю</span>
						<img data-src="/images/i-dont-know.jpg">
					</div>
					<aside class="notes">
						<h3>Linux лучшая система для разработчика.</h3>
						<p>Но если вам не повезло и вам приходится жить с Windows или MacOS, то с docker вы тоже сможете работать. Разве что есть некоторые особенности.</p>
						<p>Я вообще не специалист по этим системам и поэтому вам ничего про такие особенности не расскажу :)</p>
						<p>
							В реальности вам необходимо будет установить дополнительно к докеру виртуальную машину.<br />
							Именно в этой виртуальной машине и будут запускаться контейнеры, а остальную магию сделает докер.
						</p>
					</aside>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Запуск сервиса внутри контейнера

						```yaml
						version: '3'
						services:
							foliant:
								build: .
								volumes:
									- .:/usr/src/app
								working_dir: /usr/src/app
						```

						```bash
						docker-compose run --rm foliant make docx
						```
						<aside class="notes">

						</aside>
					</textarea>
				</section>
				<section>
					<h3>Выводы</h3>
					<h4 class="fragment">Изучайте docker</h4>
					<ul>
						<li class="fragment">Docker - просто начать</li>
						<li class="fragment">Docker - большие возможности</li>
						<li class="fragment">
							<span>Docker ведет к вашей прокачке</span><br />
							<span class="fragment">и повышению зарплаты :)</span>
						</li>
					</ul>
				</section>
				<section class="slogan">
						<div><p>Resume driven</p><p>development</p><p class="fragment bright">completed!</p></div>
				</section>
				<section class="thanks" data-background="/images/friends.png" data-background-size="600px">
					<h3>Спасибо!</h3>
					<h3>Вопросы?</h3>
					<p>Андрей Копылов</p>
					<p>aa74ko@gmail.com</p>
					<p>https://github.com/aak74/docker-driven-development</p>
					<br />
					<strong>
						<p>Мы нанимаем:</p>
						<p>job@arealidea.ru</p>
					</strong>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
				]
			});
			Reveal.configure({ slideNumber: true });
		</script>
	</body>
</html>
