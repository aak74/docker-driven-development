<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Docker Driven Development</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/github.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section class="title" data-background="/images/docker.png" data-background-size="400px" data-background-opacity="0.2">
					<h1>Docker Driven Development</h1>
					<p class="center">Нужен ли Docker для разработки?</p>
				</section>
				<section>
					<h3>Эволюция процесса разработки</h3>
					<p class="center">на примере разработки сайтов на базе LAMP</p>
					<ol>
						<li class="fragment">Denwer, WAMP, XAMP</li>
						<li class="fragment">Виртуалка + FTP</li>
						<li class="fragment">Виртуалка + Samba</li>
						<li class="fragment">Linux как основная OS</li>
						<li class="fragment">Код на локальной машине + lsync (realsync)</li>
						<li class="fragment">Docker</li>
					</ol>
					<aside class="notes">
						Описание эволюции моего процесса разработки
					</aside>
				</section>
				<section>
					<h3>Эволюция процесса разработки</h3>
					<image data-src="/images/dev-matrix.png"></image>
				</section>
				<section>
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="fragment">
							<span>Версии ПО отличаются на проде и на компьютере разработчика</span>
							<ul>
								<li class="fragment">Сложность установки ПО</li>
								<li class="fragment">Нет нужной версии ПО под вашу OS</li>
							</ul>
						</li>
						<li class="fragment">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="fragment">Сложное развертывание проекта</li>
						<li class="fragment">Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes mini" data-markdown>
						# Недостатки стандартного подхода к разработке

						## Версии ПО отличаются на проде и на компьютере разработчика
						Средний разработчик часто не задумывается о необходимости совпадения версий ПО на проде и на своем компьютере. Допускаю, что он и не должен об этом задумываться. Это может быть проблемой его старших коллег. Однако для старших коллег соблюдение версий ПО приводит к внушительному вороху проблем.

						Почему это важно?
						Почему это происходит?

						## Нет нужной версии ПО под вашу OS
						Случается, что ПО недоступно для установки на конкретно вашу OS. 
						Придется установить виртуалку с нужной OS, а ПО устанавливать в виртуалку. Однако это не снимает проблему со сложностью установки.
						
						## Сложность установки ПО
						Уверен, что каждый из нас сталкивался со сложностями в установке ПО. Этого очень сложно избежать, потому что:
						1. Само ПО достаточно сложное.
						1. Оно зависит от другого ПО.
						1. Оно может быть несовместимо с уже установленным ПО.
						1. Инструкции по установке неточны.
						
						Вышеозначенные причины могут привести к таким вариантам:
						1. Придется потратить много времени на установку.
						1. Придется пригласить админа, который в состоянии помочь в установке конкретного ПО.
						1. Установка будет невозможна.
						
						## Сложное развертывание проекта
						При развитии проекта очень часто нужно вводить нового разработчика в проект. И тут сразу возникают сложности:
						1. Для развертывания сложного проекта требуются сложные инструкции.
						1. Сложная инструкция требует много времени для разработки. Причем это время должен потратить один из самых опытных разработчиков.
						1. Если инструкция все таки написана, то само развертывание проекта для нового разработчика все равно представляет собой сложную задачу. 
						1. Каждое развертывание занимает много времени.
						
						Проблема зачастую заключается в том, что в такого рода инструкциях очень много шагов.
						Ошибка на любом этапе приводит к невозможности установки.
						Для выполнения даже самых простых задач на таком проекте требуется потратить очень много времени.
						Частая ситуация: нужно _покрасить_ кнопочку или внести другие схожие изменения. Эта работа обычно занимает 15-30 минут времени. Причем эту работу в состоянии выполнить и junior. А на развертывание проекта легко уходит от одного часа и более. Причем квалификация человека, который разворачивает проект, должна быть выше квалификации конечного исполнителя. Простейшая задача становится дорогой. А такие затраты сложно объяснить заказчику. 
						
						В итоге возможны варианты:
						1. Задачу будет исполнять специалист, у которого уже развернут этот проект. И это все равно приведет к проблемам:
								- это будет сделано только тогда, когда у него появится на это время;
								- простая задача должна быть исполнена дорогим специалистом.
						1. В проект привлечен новый специалист, но потрачено огромное количество времени на его привлечение.
						1. Задача может быть не выполнена вообще.
						
						## Очень сложно исполнять один и тот же код с разными версиями ПО или с разными настройками
						Зачем это вообще может понадобиться?
						Мне в голову приходят следующие варианты:
						1. Тестирование проекта в различных окружениях. Например планируется переход на новую версию серверного ПО или новую версию интерпретатора (компилятора).
						1. Тестирование продуктов собственной разработки в различных окружениях. Например у клиентов ваше ПО используется в различных окружениях. Для поставки качественного продукта вам необходимо свое ПО тестировать в окружении __идентичном__ окружению клиента.
						1. Тестирование библиотеки собственной разработки. Вы поставляете на рынок библиотеку, а клиенты используют ее в каких-то очень __специфических__ окружениях.
						
						Все эти проблемы решаются с помощью виртуалок. Но процесс развертывания достаточно долгий. А хранение и перенос виртуалок между разработчиками может быть затруднен.
						
						## Устанавливаемое ПО засоряет компьютер разработчика
						Установленное ПО занимает не только место на диске, но и зачастую запускает дополнительные процессы в системе. Таким образом съедаются процессорные мощности вашего компьютера.
						Если для установленного ПО выходят обновления, то вы их скачиваете без особой на то надобности. Сразу вспоминается Skype, который в последнее время обновляется чуть ли не ежедневно.
					</aside>
				</section>
				<section class="intro" data-background="/images/docker.png" data-background-size="800px" data-background-opacity="0.5">
					<h2>Введение</h2>
				</section>
				<section data-transition="none">
					<h3>Образ и контейнер</h3>
					<ul>
						<li class="fragment">Образ и контейнер</li>
						<li class="fragment">
							<span>
								Распространение образов
							</span>
							<ul>
								<li class="fragment">Официальные образы</li>
								<li class="fragment">Кастомные образы на Docker Hub</li>
								<li class="fragment">Кастомные образы в приватном Docker Registry</li>
							</ul>
						</li>
					</ul>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Запуск контейнера (docker run)
						```bash
						docker run -d \
							-p 27017:27017 
							--volume=./data/mongo:/db/data \
							mongo:3-stretch
						```
						<aside class="notes" data-markdown>
							- -d
							- Порты
							- Тома
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Dockerfile
						```yaml
						FROM mongo:3-stretch

						COPY ./mongo.conf /usr/local/etc/mongo/mongo.conf
						EXPOSE 27017
						
						CMD ["mongod"]						
						```
						<aside class="notes mini" data-markdown>
							- Начальный образ
							- Указать на конкретную версию (тегирование)
							- Копирование
							- EXPOSE
							- CMD
							- указать на слои (одна строка = один слой)
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### docker-compose
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup:/backup
								restart: always
						```
						<aside class="notes mini" data-markdown>
						</aside>
					</textarea>
				</section>
				<section>
					<h3>Примеры</h3>
					<ol>
						<li class="mini">Установка БД</li>
						<li class="mini">Тестирование с использованием БД</li>
						<li class="mini">Полноценное использование БД</li>
						<li class="mini">Запуск простого проекта на локальном компьютере</li>
						<li class="mini">Переключение между состояниями БД</li>
						<li class="mini">Переключение между настройками одного и того же ПО</li>
						<li class="mini">Переключение между версиями ПО</li>
						<li class="mini">Переключение между пользователями</li>
						<li class="mini">Тестирование с использованием mock сервиса</li>
					</ol>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Установка БД
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup:/backup
								restart: always
						```
						<aside class="notes mini" data-markdown>
							## Описание проблемы 
							Первой проблемой, которая меня подтолкнула к контейнерам была невозможность 
							установки конкретной версии MySQL на свой компьютер. Проблема заключалась в том,
							что у меня уже стояла одна из предыдущих версий и отказываться от нее не входило в мои планы.
							
							## Решение
							Устанавливаем БД в контейнере.
							
							1. Берем готовый образ из Docker Hub.
							1. Указываем порт, который будет доступен на локальном компьютере.
							1. Монтируем том, который будет содержать данные.
							1. Остается только развернуть БД из бэкапа

							docker exec -it db sh -c "mysql -u root -p db < /backup/db.sql"

							Конкретно для mysql есть вариант первоначального восстановления из бэкапа проще. 
							Но он не рассмотрен для простоты.
						</aside>
					</textarea>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li>Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Сложное развертывание проекта</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Запуск простого проекта на локальном компьютере
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7-apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html
						```
					</textarea>
				</section>
				<section>
					<h3>Версии ПО или разные настройки</h3>
					<ul>
						<li class="fragment">Подключение дебаггера.</li>
						<li class="fragment">Компиляция проекта разными версиями.</li>
						<li class="fragment">Тестирование проекта в различных окружениях</li>
						<li class="fragment">Тестирование продуктов собственной разработки в различных окружениях.</li>
					</ul>
				</section>
				<section>
					<h3>Переключение между пользователями</h3>
					<ul>
						<li class="fragment">Сложная логика работы с пользователями.</li>
						<li class="fragment">Пользователи с разными ролями.</li>
						<li class="fragment">Необходимость использования одинаковых средств отладки.</li>
					</ul>
				</section>
				<section>
						<h2>Тестирование с использованием БД</h2>
						<ol>
							<li class="fragment">Ручное тестирование скриптов</li>
							<li class="fragment">Ручное тестирование функционала</li>
							<li class="fragment">
								<span>Unit тестирование</span>
								<ul>
									<li class="fragment">Лучше не надо</li>
									<li class="fragment">Но если очень хочется...</li>
								</ul>
							</li>
						</ol>					
					</section>
					<section data-markdown>
						<textarea data-template>
							#### Стандартный подход к тестированию с использованием БД
							1. Создать БД и наполнить БД нужными данными, либо восстановить ее из бэкапа.
							1. Выполнить тесты.
							1. Удалить или очистить БД.
						</textarea>
					</section>
					<section data-markdown>
						<textarea data-template>
							#### Современый подход к тестированию с использованием БД
							1. Создать __один раз__ контейнер содержащий БД.
							1. Запускаем контейнер.
							1. Запускаем тесты.
							1. Останавливаем контейнер.						
						</textarea>
					</section>
	
				<section>
					<h3>Тестирование с использованием mock-сервиса</h3>
				</section>
				<section data-markdown>
						<textarea data-template>
							### Структура папок
							```bash
							|-- containers
							|   |-- apache
							|   |   |-- rootfs
							|   |   |   `-- etc
							|   |   `-- Dockerfile
							|   `-- mysql
							|       |-- rootfs
							|       |   `-- etc
							|       `-- Dockerfile
							|-- data
							|   `-- mysql
							|-- logs
							|   |-- apache
							|   `-- mysql
							|-- src
							`-- docker-compose.yml
								```
						</textarea>
					</section>
					<section>
					<h3>Дополнительные вопросы</h3>
					<ul>
						<li class="fragment">Пользователь в Dockerfile</li>
						<li class="fragment">Переменные среды</li>
						<li class="fragment">Документирование (Инфраструктура как код)</li>
						<li class="fragment">Слоистая структура образов</li>
						<li class="fragment">Устаревшие образы продолжают занимать место</li>
						<li class="fragment">Использование Docker в Windows и MacOS</li>
						<li class="fragment">Запуск сервиса внутри контейнера (docker-compose run)</li>
					</ul>
				</section>
				<section>
					<h3>Выводы</h3>
					<ul>
						<li class="fragment">Docker - просто начать</li>
						<li class="fragment">Docker - большие возможности</li>
					</ul>
				</section>
				<section>
						<h1><span>Resume</span><span class="fragment"> driven</span><span class="fragment"> development</span> <span class="fragment bright"> completed!</span></h1>
				</section>
				<section class="thanks" data-background="/images/friends.png" data-background-size="600px">
					<h3>Спасибо!</h3>
					<h3>Вопросы?</h3>
					<p>Андрей Копылов</p>
					<p>aa74ko@gmail.com</p>
					<p>https://github.com/aak74/docker-driven-development</p>
					<br />
					<strong>
						<p>Мы нанимаем:</p>
						<p>job@arealidea.ru</p>
					</strong>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
