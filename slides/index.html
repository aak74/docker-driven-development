<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Docker Driven Development</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/github.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section class="title" data-background="/images/docker.png" data-background-size="400px" data-background-opacity="0.2">
					<h1>Docker Driven Development</h1>
					<p class="center">Нужен ли Docker для разработки?</p>
					<aside class="notes">
						<p>Бытует мнение, что docker сложен и нужен только для использования на проде. И даже там он нужен только корпорациям. </p>
						<p>Я попробую доказать, что docker может и должен использоваться в процессе разработки на компьютерах разработчиков. Это утверждение верно даже если на проде у вас нет и не будет docker-а.</p>
					</aside>
				</section>
				<section class="about">
					<h2>About</h2>
					<p class="me">Андрей Копылов</p>
					<ul>
						<li>В веб-разработке с 2006</li>
						<li>Технический директор AREALIDEA</li>
					</ul>
					<p>aa74ko@gmail.com</p>
					<aside class="notes" data-markdown>
						В веб-разработке с 2006.

						Зарабатывать программированием на жизнь начал 25 лет назад.
						Сейчас работаю техническим директором в компании AREALIDEA.

						Стараюсь создать условия для эффективной работы разработчиков.

						При этом остаюсь играющим тренером. 
						И как мне кажется вижу боль с двух сторон.

						Давайте об этом и поговорим.
					</aside>
				</section>
				<section>
					<h3>Эволюция процесса разработки</h3>
					<p class="center">на примере разработки сайтов на базе LAMP</p>
					<ol>
						<li>Denwer, WAMP, XAMP</li>
						<li>Виртуалка + FTP (Samba)</li>
						<li>Linux как основная OS</li>
						<li>Код на локальной машине + lsync (realsync)</li>
						<li>Docker</li>
					</ol>
					<aside class="notes" data-markdown>
						Вообще-то на месте этого слайда должен быть слайд с кровищей :)

						- Кто использует в работе схожий стек технологий?
						- А кто раньше использовал?
					</aside>
				</section>
				<section>
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="fragment">
							<span>Версии ПО отличаются на проде и на компьютере разработчика</span>
							<ul>
								<li class="fragment">Сложность установки ПО</li>
								<li class="fragment">Нет нужной версии ПО под вашу OS</li>
							</ul>
						</li>
						<li class="fragment">Сложное развертывание проекта</li>
						<li class="fragment">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="fragment">Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes mini" data-markdown>
						# Недостатки стандартного подхода к разработке
						Почему сейчас я хочу поговорить о технологии docker?
						Зачем она нужна разработчику?

						Дело в том, что у стандартного подхода к разработке есть ряд недостатков.

						## Версии ПО отличаются на проде и на компьютере разработчика
						Средний разработчик часто не задумывается о необходимости совпадения версий ПО на проде и на своем компьютере. Допускаю, что он и не должен об этом задумываться. Это может быть проблемой его старших коллег. Однако для старших коллег соблюдение версий ПО приводит к внушительному вороху проблем.

						### Почему это происходит?
						- Сложность установки ПО
						- Нет нужной версии ПО под вашу OS
						
						### Очень сложно исполнять один и тот же код с разными версиями ПО или с разными настройками
						
						Проблема решается с помощью виртуалок. Но процесс развертывания достаточно долгий. 
						А хранение и перенос виртуалок между разработчиками может быть затруднен.
						
						## Сложное развертывание проекта
						Проблема решается с помощью виртуалок.

						При развитии проекта очень часто нужно вводить нового разработчика в проект. И тут сразу возникают сложности:
						1. Для развертывания сложного проекта требуются сложные инструкции.
						1. Сложная инструкция требует много времени для разработки. Причем это время должен потратить один из самых опытных разработчиков.
						1. Если инструкция все таки написана, то само развертывание проекта для нового разработчика все равно представляет собой сложную задачу. 
						1. Каждое развертывание занимает много времени.
						
						Проблема зачастую заключается в том, что в такого рода инструкциях очень много шагов.
						Ошибка на любом этапе приводит к невозможности установки.
						Для выполнения даже самых простых задач на таком проекте требуется потратить очень много времени.
						Частая ситуация: нужно _покрасить_ кнопочку или внести другие схожие изменения. Эта работа обычно занимает 15-30 минут времени. Причем эту работу в состоянии выполнить и junior. А на развертывание проекта легко уходит от одного часа и более. Причем квалификация человека, который разворачивает проект, должна быть выше квалификации конечного исполнителя. Простейшая задача становится дорогой. А такие затраты сложно объяснить заказчику. 
						
						В итоге возможны варианты:
						1. Задачу будет исполнять специалист, у которого уже развернут этот проект. И это все равно приведет к проблемам:
								- это будет сделано только тогда, когда у него появится на это время;
								- простая задача должна быть исполнена дорогим специалистом.
						1. В проект привлечен новый специалист, но потрачено огромное количество времени на его привлечение.
						1. Задача может быть не выполнена вообще.


						## Устанавливаемое ПО засоряет компьютер разработчика
						- Если для установленного ПО выходят обновления, то вы их скачиваете без особой на то надобности. Сразу вспоминается
						Skype, который в последнее время обновляется чуть ли не ежедневно.

						На мой взгляд ни одна из проблем не решается этот спектр проблем полностьб не решается ничем кроме Докера.
					</aside>
				</section>
				<section>
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li>Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложное развертывание проекта</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes mini" data-markdown>
						- Кто из вас сталкивался с подобными проблемами?
						- Кто их полностью решил?
						- Кто считает. что это вовсе не проблемы?

						### Версии ПО отличаются на проде и на компьютере разработчика
						Решается с помощью виртуалок.

						### Сложное развертывание проекта
						Частично решается с помощью виртуалок.

						### Сложно исполнять один и тот же код с разными версиями ПО
						Частично решается с помощью виртуалок.
						
						### Устанавливаемое ПО засоряет компьютер разработчика
						Частично решается с помощью виртуалок.
						Но при этом усугубляет проблему с местом на диске.

						Если не использовать виртуалки, то
						- Установленное ПО занимает не только место на диске, но и зачастую запускает дополнительные процессы в системе. Таким
						образом съедаются процессорные мощности вашего компьютера.

						Использование виртуалок ведет к другим проблемам:
						- существенное потребление дискового пространства
						- есть сложности распространения (есть частичные решения типа Vagrant)
						- долго запускаются

						При этом виртуалки полностью проблемы не решают.

						Есть ли решение у этой проблемы?
					</aside>
				</section>

				<section>
					<h2>Docker <span class="bright">решает</span></h2>
					<div class="fragment center">
						<p>все эти проблемы</p>
						<p>и даже больше</p>
					</div>
				</section>
				<section class="intro" data-background="/images/docker.png" data-background-size="800px" data-background-opacity="0.5">
					<h2>Введение</h2>
					<aside class="notes" data-markdown>
						Прежде чем продолжить наш разговор хотелось бы задать пару вопросов:
						- Кто-то пользуется докером в процессе разработки?
						- У кого-то есть докер на проде?
						- Есть в зале люди, которые не знают что такое докер?

						Для тех, кто не знает что такое докер предлагаю пробежаться по основным терминам.

						Те кто знают долго скучать не будет, ибо бежать будем быстро.
					</aside>
				</section>
				<section data-transition="none">
					<h3>Введение</h3>
					<ul>
						<li class="fragment">Образ и контейнер</li>
						<li class="fragment">
							<span>
								Распространение образов
							</span>
							<ul>
								<li class="fragment">Официальные образы</li>
								<li class="fragment">Кастомные образы на Docker Hub</li>
								<li class="fragment">Кастомные образы в приватном Docker Registry</li>
							</ul>
						</li>
					</ul>
					<aside class="notes" data-markdown>
						## Образ и контейнер
						- Образ это неизменяемый слепок файловой системы.
						- Контейнер это образ, в котором запущен хотя бы один процесс.
						## Распространение образов
						- На первом этапе бывает достаточно использовать официальные образы, которые создают сами произволители ПО.
						- Эти образы распространяются через Docker HUB.
						- При необходимости образы можно кастомизировать и для хранения и распространения вы можете использовать все тот же Docker HUB.
						- Или использовать self hosted решения Docker Registry, нопример Gitlab
					</aside>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Запуск контейнера (docker run)
						```bash
						docker run -d \
							-p 27017:27017 
							--volume=./data/mongo:/db/data \
							mongo:3-stretch
						```
						<aside class="notes" data-markdown>
							- Запуск контейнера, который содержит 3 версию MongoDB
							- Разве вы видели более простую установку?
							- -d
							- Порты
							- Тома
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Dockerfile
						```yaml
						FROM mongo:3-stretch

						COPY ./mongo.conf /usr/local/etc/mongo/mongo.conf
						```
						<aside class="notes" data-markdown>
							Если вас не устраивает стандартный конфиг, то его легко поменять создав Dockerfile

							- Первым делом мы выбираем начальный образ
							- Очень желательно указать **конкретную версию** образа, это в дальнейшем вам поможет избежать проблем с разными версиями
							- Копирование конфига
							- Каждая строка ведет к появлению нового слоя
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mongo:3-stretch
								ports:
									- 27017:27017
								volumes:
									- ./data/mongo:/db/data
								restart: always
						```

						```bash
						docker-compose up --build -d
						```
						<aside class="notes" data-markdown>
							Вместо того, чтобы указывать подключаемые тома при каждом запуске контейнера можно создать файл docker-compose.yml

							В этом файле можно описать все необходимые параметры. Запуск контейнера становится совсем простым
						</aside>
					</textarea>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
								restart: always
							
							rabbitmq:
								image: rabbitmq:3.7
								volumes:
									- ./data/rabbitmq:/var/lib/rabbitmq
								restart: always
						
							redis:
								image: redis
								command: ["redis-server", "--appendonly", "yes"]
						```
						<aside class="notes" data-markdown>
							Здесь описано три сервиса, которые запускаются все той же одной командой.

							Проще не бывает. Не так ли?
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-l">
					<textarea data-template>
						#### Структура папок
						```bash
						|-- containers/
						|-- data/
						|-- logs/
						|-- src/
						|-- Makefile
						`-- docker-compose.yml
						```
						<aside class="notes" data-markdown>
							Пройдя эволюционный путь мы пришли к такой структуре папок при использовании контейнеров.

							Сейчас во всех проектах компании AREALIDEA мы используем такую структуру.
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						#### Структура папок
						```bash
						|-- containers
						|   |-- apache
						|   |   |-- rootfs
						|   |   |   `-- etc
						|   |   `-- Dockerfile
						|   `-- mysql
						|       |-- rootfs
						|       |   `-- etc
						|       `-- Dockerfile
						|-- data
						|   |-- mongodb
						|   |-- mysql
						|   `-- redis
						|-- logs
						|   |-- apache
						|   |-- mongodb
						|   |-- mysql
						|   `-- redis
						|-- src
						|   |-- service1
						|   |-- service2
						|   `-- service3
						|-- Makefile
						`-- docker-compose.yml
						```
						<aside class="notes" data-markdown>
							Развернем структуру на один уровень глубже.

							Тут комментарии тоже вряд ли нужны
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Структура файлов для описания контейнера
						```bash
						|-- apache2
						|   |-- rootfs
						|   |   `-- etc
						|   |       |-- apache2
						|   |       |   |-- conf-available
						|   |       |   |   `-- remoteip.conf
						|   |       |   |-- mods-available
						|   |       |   |   `-- remoteip.conf
						|   |       |   `-- sites-available
						|   |       |       |-- 000-default.conf
						|   |       |       `-- default-ssl.conf
						|   |       `-- php
						|   |           `-- 7.2
						|   |               |-- apache2
						|   |               |   `-- php.ini
						|   |               `-- cli
						|   |                   `-- php.ini
						|   `-- Dockerfile
						```
						<aside class="notes" data-markdown>
							Чуть более подробно посмотрим на файловую структуру описания контейнера.
						
							Обращаю внимание на папку rootfs, внутри которой повторяется структура файловой системы образа.
							Обычно внутри таких папок располагаются конфиги. Эти конфиги в дальнейшем будут **одной** командой скопированы внутрь образа.
							Причем после добавления новых конфигов вам не нужно переписывать Dockerfile, как при другом подходе.
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Dockerfile
						```yaml
						FROM php:7.2-apache

						COPY ./rootfs /
						```
						<aside class="notes" data-markdown>
							В рассматриваемом примере Dockerfile очень прост.

							Кроме старта с базового образа необходимо лишь скопировать папку rootfs в корневую папку образа.

							На этом введение заканчиваем и переходим к решению обозначенных проблем.
						</aside>
					</textarea>
				</section>
				<section>
					<h2>Решение проблем</h2>
					<ol>
						<li>Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложное развертывание проекта</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes" data-markdown>
						Напоминаю проблемы, которые я пообещал решить с помощью докера.
					</aside>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Установка БД
						```yaml
						version: '2'

						services:
							mysql:
								image: mariadb:10
								ports:
									- 3306:3306
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup:/backup
								restart: always
						```
						<aside class="notes mini" data-markdown>
							## Описание проблемы 
							Первой проблемой, которая меня подтолкнула к контейнерам была невозможность 
							установки MariaDB вместе с MySQL на свой компьютер.
							От MySQL я не собирался отказываться и стандартный подход мне никак не помог в решении проблемы.

							И даже заменить MySQL на MariaDB у меня не получилось.

							Для меня установка ПО на Linux в тот момент была существенной проблемой.

							В тот момент я так и не смог решить эту проблему.
							
							## Решение
							Запускаем сервер БД в контейнере.
							
							1. Берем готовый образ из Docker Hub.
							1. Указываем порт, на котором БД будет доступна на локальном компьютере.
							1. Монтируем том, который будет содержать данные.
							1. Остается только развернуть БД из бэкапа
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Восстановление БД из backup

						```bash
						docker exec -it mysql sh -c "mysql -u root -p db < /backup/db.sql"
						```

						```bash
						make restore
						```
						<aside class="notes" data-markdown>
							Восстановить БД из бэкапа довольно просто. Это сейчас видно на экране.
							Команда ненамного сложней стандартной.

							Идеальным вариантом будет использование утилиты `make`. 
							При этом команда восстановления из БД становится совсем тривиальной.

							Тогда один раз написанный `Makefile` можно распространить на все проекты.

							Команда будет не просто очень простая, но еще и она будет одинаковой для всех проектов, которые используют подобную схему.
							
							Конкретно для mysql есть вариант первоначального восстановления из бэкапа проще. 
							Но он не рассмотрен для простоты.
						</aside>
					</textarea>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li>Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложное развертывание проекта</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложное развертывание проекта</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>

				<section>
					<h3>Сложное развертывание проекта</h3>
					<ul>
						<li class="fragment">Установить MySQL версии 5.7.23</li>
						<li class="fragment">Установить RabbitMQ 3.7.7</li>
						<li class="fragment">Установить Redis 4.0.8</li>
						<li class="fragment">Сделать дамп БД на сервере ...</li>
						<li class="fragment">Для MySQL установить настройку max_allowed_packet=128M ...</li>
						<li class="fragment">Восстановить БД из полученного дампа на сервере ...</li>
					</ul>
						<aside class="notes" data-markdown>
							На слайде представлена очень небольшая часть инструкции по развертыванию проекта.

							## Кому в зале представляется развертывание подобного проекта простым?

							А если представить, что проект нужно развернуть для правки мелкого бага или даже просто перекрашивания кнопки в другой цвет?

							Человек, который не является большим специалистом по установке всех перечисленных систем,
							обязательно столкнется с ворохом проблем. А соответственно процесс исправления тривиального бага 
							может существенно затянуться.
						</aside>					
				</section>

				<section data-markdown class="size-xs">
					<textarea data-template>
						### Сложное развертывание проекта

						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:5.7.23
								container_name: db
								ports:
									- 3306:3306
								environment:
									MYSQL_DATABASE: db
									MYSQL_USER: my_user
									MYSQL_PASSWORD: 123
									MYSQL_ROOT_PASSWORD: 123
								volumes:
									- ./data/mysql:/var/lib/mysql
									- ./data/backup/mysql:/bakup
								restart: always
							
							rabbitmq:
								image: rabbitmq:3.7.7
								ports:
									- 5672:5672
								volumes:
									- ./data/rabbitmq:/var/lib/rabbitmq
								restart: always
						
							redis:
								image: redis:4.0.8
								command: ["redis-server", "--appendonly", "yes"]
						```
						<aside class="notes" data-markdown>
							Вот так эту задачу можно решить с помощью докера.
							Через пять минут проект будет запущен на компьютере любого разработчика.

							- При стандартном подходе к разворачиванию ПО сложность растет в геометрической прогрессии в зависимости от числа элементов.
							- При использовании докера сложность растет линейно.
							- Причем эта сложность существует только для специалиста, который описывает систему.
							- Остальные разработчики просто пользуются готовой системой.
						</aside>
					</textarea>
				</section>				
				<section data-markdown class="mini">
					<textarea data-template>
						### Сложное развертывание проекта
						#### Makefile
						```
						...

						init: download restore
						
						download:
							@echo "Starting download database"
							scp user@example.com:/path/to/backup/db.sql ./backup/mysql/db.sql

						restore:
							@echo "Starting restore database"
							docker exec -it db sh -c "mysql -u root -p123 db < /backup/db.sql"
						```
						<aside class="notes" data-markdown>
							Еще больше упростить жизнь можно с помощью утилиты make.

							В последнее время я существенно подсел на эту волшебную утилиту.

							Достаточно запустить команду `make init` и дамп базы данных скачается, 
							и восстановится внутри вашего контейнера.

							Добавить удаленное создание дампа БД так же легко.
						</aside>
					</textarea>
				</section>		
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li>Сложное развертывание проекта</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>						
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes">
						Со сложностью развертывания проекта тоже разобрались.
					</aside>
				</section>

				<section>
					<h3>Версии ПО или разные настройки</h3>
					<ul>
						<li>Тестирование проекта в различных окружениях.</li>
						<li>Тестирование продуктов собственной разработки в различных окружениях.</li>
						<li>Компиляция проекта разными версиями компилятора.</li>
						<li>Подключение дебаггера.</li>
					</ul>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Запуск простого проекта на локальном компьютере
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes">
							Для начала рассмотрим запуск простейшего проекта.
							Предположим, что вы хотите протестировать готовность вашего проекта к переходу на свежайшую версию интерпретатора.
							В случае использования виртуалки вам пришлось бы долго создавать новую виртуалку, копировать туда ваш код и делать еще кучу шагов.
							Оценив временные затраты скорее всего вы даже не стали это пробовать.

							Без виртуалки все было бы еще хуже.
						</aside>
					</textarea>
				</section>
				<section data-markdown class="mini">
					<textarea data-template>
						### Тестирование проекта в различных окружениях
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html

							server73:
								image: php:7.3-apache
								ports:
									- 8073:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes" data-markdown>
							Что нам предлагает докер?

							Размножаем описанный нами сервис.

							- Новую версию ПО цепляем на другой порт.
							- Том оставляем тот же самый.

							Теперь у нас две версии нашего сайта, которые доступны одновременно и базируются на одном и том же коде.
						</aside>
					</textarea>
				</section>

				<section data-markdown class="size-s">
					<textarea data-template>
						### Компиляция кода конкретной версией компилятора

						#### docker-compose.yml
						```yaml
						version: '3'
						services:
							compile_11:
								image: golang:1.11-alpine
								volumes:
									- ./src:/go
								working_dir: /go						

							compile_9:
								image: golang:1.9-alpine
								volumes:
									- ./src:/go
								working_dir: /go						
						```

						#### Компиляция
						```bash
						docker-compose run --rm compile_11 go build -o main
						```
						<aside class="notes" data-markdown>
							Следующая ситуация.

							Вам необходимо скомпилировать свой проект разными версиями компилятора.
							При этом у вас установлен golang версии 1.10.

							Создаем docker-compose.yml с указанными сервисами.
							Компилируем с указанием нужного сервиса.

							Это все.

							GOPATH и вендоринг опущен за несущественностью. Реализовать это внутри контейнера очень просто.
						</aside>
					</textarea>
				</section>
				
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера 
						#### docker-compose.yml
						```yaml
						version: '2'
				
						services:
							server:
								build: ./containers/apache
								ports:
									- 80:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes">
							Для подключения дебаггера нужно чуть-чуть изменить docker-compose.yml
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера
						#### Измененный ini файл
						```bash
						cat ./containers/apache2/rootfs/etc/php/7.2/apache2/php.ini | grep xdebug
						```
						```ini
						[xdebug]
						xdebug.remote_host = "172.19.0.1"
						xdebug.remote_port = 9000
						xdebug.remote_autostart = 1
						xdebug.remote_enable = 1
						```
						<aside class="notes" data-markdown>
							Изменяем настройки.

							Следует отметить, что IP адрес может изменяться.
							Стоит IP адрес передавать через переменные окружения.
							Cистема становится несколько сложнее и для демонстрации эти возможности опущены.
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Подключение дебаггера
						#### Dockerfile
						```yaml
						FROM php:7.2-apache
						
						RUN DEBIAN_FRONTEND=noninteractive apt-get -y install \
							php7.2-xdebug
											
						COPY ./rootfs /
						```
						<aside class="notes">
							В Dockerfile добавляем новый модуль.
							Копируем новый конфиг.

							И все.
						</aside>
					</textarea>
				</section>


				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li>Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				
				<section>
					<h3>Устанавливаемое ПО засоряет компьютер разработчика</h3>
					<ul>
						<li class="fragment">Только запущенный контейнер потребляет память и CPU</li>
						<li class="fragment">Виртуалки занимают много места</li>
						<li class="fragment">Образ состоит из слоев</li>
						<li class="fragment">От устаревших образов и отдельных слоев можно и нужно избавляться</li>
					</ul>
					<aside class="notes" data-markdown>
						Если вы не устанавливаете весь софт на локальный компьютер, то он сжирает оперативную память и потребляет CPU.
						30% производительности которого у нас не так давно украла Интел.
						
						В случае использования докера: Только запущенный контейнер потребляет память и CPU.

						При использовании виртуалок с CPU все относительно неплохо, но память все также пожирается виртуалкой.
						А уж сколько виртуалки занимают места на диске...

						## Слоистая структура образов
						Докер и здесь нам существенно помогает.

						Каждый образ состоит из нескольких слоев. Каждая команда внутри Dockerfile создает новый слой.
						Такой подход обеспечивает переиспользование слоя и экономит место на диске и ускоряет сборку образа.

						При повторной сборке образа учитываются изменения в `Dockerfile` и изменения в файлах, которые участвуют в сборке.
						Если изменений в `Dockerfile` не было, то образ _соберется_ очень быстро.
						Чем выше в `Dockerfile` были изменения тем больше слоев нужно пересобирать. То есть часто изменяемые настройки следует помещать ближе к концу `Dockerfile`.

						Тем не менее от устаревших образов и отдельных слоев можно и нужно избавляться.
					</aside>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Чистка устаревших образов
						```
						docker system prune
						```
						<aside class="notes" data-markdown>
							Сделать это можно командой, показанной на слайде.
							
							Однако это не решает всех проблем.
							Думаю, что изучение данного вопроса не вызовет проблем.
							А можно просто купить SSD побольше. :)

							Хотя вам это не пригодится, вы ведь очень скоро удалите все свои виртуалки за ненадобностью.
						</aside>
					</textarea>						
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li>Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
				</section>
				<section data-transition="none">
					<h3>Недостатки стандартного подхода к разработке</h3>
					<ol>
						<li class="strike">Версии ПО отличаются на проде и на компьютере разработчика</li>
						<li class="strike">Сложное развертывание проекта</li>
						<li class="strike">Сложно исполнять один и тот же код с разными версиями ПО</li>
						<li class="strike">Устанавливаемое ПО засоряет компьютер разработчика</li>
					</ol>
					<aside class="notes" data-markdown>
						Похоже, что обозначенные проблемы докер порешал.

						Кто из присутствующих считает, что проблемы решены?
						А кто считает иначе?
					</aside>
				</section>
				<section>
					<h2>Еще примеры</h2>
					<aside class="notes" data-markdown>
						Считаю необходимым осветить еще пару примеров.
					</aside>
				</section>				
				<section>
					<h2>Тестирование с использованием БД</h2>
					<ol>
						<li class="fragment">Ручное тестирование скриптов</li>
						<li class="fragment">Ручное тестирование функционала</li>
						<li class="fragment">
							<span>Unit тестирование</span>
							<ul>
								<li class="fragment bright">Лучше не надо</li>
								<li class="fragment">Но если очень хочется...</li>
							</ul>
						</li>
					</ol>					
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Стандартный подход к тестированию с использованием БД
						1. Восстановление БД из бэкапа.
						1. Выполнить тесты.
						1. Удалить или очистить БД.
						<aside class="notes">
							<p>Если БД достаточно большая, то и восстанавливаться она будет долго.</p>
							<p>Этот процесс нужно выполнять при каждом тестировании.</p>
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Использование docker для тестирования с использованием БД
						1. Создать __один раз__ образ содержащий БД.
						1. Запускаем контейнер.
						1. Запускаем тесты.
						1. Останавливаем контейнер.						
						<aside class="notes" data-markdown>
							Настойчиво обращаю внимание на то, что образ нужно подготовить один раз.
							Такой образ можно сохранить в docker registry и в вашем проекте будет автоматически использоваться нужная версия БД для тестирования.
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Использование docker для тестирования с использованием БД

						##### Dockerfile

						```yaml
						FROM mysql:8

						COPY ./db.sql /backup/

						RUN mysql -u root -p db < /backup/db.sql \
							&& rm /backup/db.sql
						```
						<aside class="notes" data-markdown>
							- Создаем образ от базового.
							- Копируем дамп БД внутрь образа.
							- Запускаем восстановление БД и удаление дампа в одной команде.

							Таким образом получается минимальный размер образа.
						</aside>
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						#### Использование docker для тестирования с использованием БД

						##### build

						```bash
						docker build \
							--rm -f ./Dockerfile \
							-t test/db:0.1 .
						```

						##### Dockerfile
						```yaml
						FROM test/db:0.1
						```
						<aside class="notes" data-markdown>
							- Собираем образ
							- Помечаем его тегом
							- Используем полученный образ в наших тестах
						</aside>
					</textarea>
				</section>
				<section>
					<h3>Переключение между пользователями</h3>
					<ul>
						<li class="fragment">Сложная логика работы с пользователями.</li>
						<li class="fragment">Пользователи с разными ролями.</li>
						<li class="fragment">Необходимость использования одинаковых средств отладки.</li>
					</ul>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Переключение между пользователями
						#### docker-compose.yml
						```yaml
						version: '2'
				
						services:
							server:
								image: php:7.2-apache
								ports:
									- 8080:80
								volumes:
									- ./src:/var/www/html
							server1:
								image: php:7.2-apache
								ports:
									- 8081:80
								volumes:
									- ./src:/var/www/html
							server2:
								image: php:7.2-apache
								ports:
									- 8082:80
								volumes:
									- ./src:/var/www/html
						```
						<aside class="notes">
							Достаточно размножить сервис и раскидать по различным портам и вы получаете нужное количество сессий в одном браузере
						</aside>
					</textarea>
				</section>
				<section>
					<h2>Дополнительные вопросы</h2>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Пользователь в Dockerfile

						##### Dockerfile
						```yaml
						FROM php:7.2-apache

						RUN usermod -u 1000 www-data
						```

						```yaml
						FROM php:7.2-cli

						USER 1000
						```
						<aside class="notes" data-markdown>
							- Если специальным образом не указать пользователя, под которым будут работать процессы в контейнере, то все процессы будут работать из под рута. Это неприемлемо с точки зрения безопасности.
							- В процессе разработки можно упростить себе жизнь не указывая пользователя, но на проде это совершенно недопустимо. Но даже в процессе разработки я не рекомендую малодушничать. Всегда указывайте пользователя, под которым будут работать процессы в контейнере.
							- В первом Dockerfile происходит замена user id для пользователя, под которым запущен процесс.
							- Во втором случае происходит замена user id для текущего пользователя
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Переменные среды

						#### docker-compose.yml
						```yaml
						version: '2'

						services:
							mysql:
								image: mysql:8
								container_name: db
								ports:
									- 3306:3306
								environment:
									MYSQL_DATABASE: ${DATABASE}
									MYSQL_USER: ${USER}
									MYSQL_PASSWORD: ${PASSWORD}
									MYSQL_ROOT_PASSWORD: ${ROOT_PASSWORD}
								volumes:
									- ./data/mysql1:/var/lib/mysq1
							```
						<aside class="notes" data-markdown >
							Очень удобно переменные среды передавать внутрь контейнера с помощью файла docker-compose.yml.

							Однако этот файл находится под системой контроля версий. И тогда на помощь приходит файл .env
						</aside>
					</textarea>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Переменные среды

						#### .env
						```ini
						DATABASE=db
						USER=user
						PASSWORD=123
						ROOT_PASSWORD=123
						```
						<aside class="notes" data-markdown>
							Для того чтобы новые переменные окружения попали в контейнер нужно обязательно пересобрать образ.
						</aside>
					</textarea>
				</section>
				<section class="size-s">
					<h3>Документирование (Инфраструктура как код)</h3>
					<p class="fragment">Лучшая документация всегда лежит рядом с кодом.</p>
					<ul>
						<li class="fragment">Dockerfile</li>
						<li class="fragment">docker-compose.yml</li>
						<li class="fragment">Makefile</li>
					</ul>
					<aside class="notes" data-markdown>
						Лучшая документация всегда лежит рядом с кодом

						Dockerfile и docker-compose.yml описывают лучше любой документации то окружение, 
						в котором должен работать проект.
						
						Makefile описывает команды, которые необходимо выполнять для того чтобы разрабатывать проект или может даже его эксплуатировать.

						Можно заставить программиста изменять документацию, которая похожа на код и лежит рядом с кодом. 
						Но нельзя заставить программиста менять документацию, которая лежит в вики.
					</aside>
				</section>
				<section>
					<h3>Использование Docker в Windows и MacOS</h3>
					<ul>
						<li class="fragment">Linux лучшая система для разработчика.</li>
						<li class="fragment">В других системах есть особенности.</li>
					</ul>
					<div class="fragment">
						<span>Но я про них ничего не знаю</span>
						<img data-src="/images/i-dont-know.jpg">
					</div>
					<aside class="notes">
						<h3>Linux лучшая система для разработчика.</h3>
						<p>Но если вам не повезло и вам приходится жить с Windows или MacOS, то с docker вы тоже сможете работать. Разве что есть некоторые особенности.</p>
						<p>Я вообще не специалист по этим системам и поэтому вам ничего про такие особенности не расскажу :)</p>
						<p>
							В реальности вам необходимо будет установить дополнительно к докеру виртуальную машину.<br />
							Именно в этой виртуальной машине и будут запускаться контейнеры, а остальную магию сделает докер.
						</p>
						Но это неточно :)
					</aside>
				</section>
				<section data-markdown class="size-s">
					<textarea data-template>
						### Запуск сервиса внутри контейнера

						```yaml
						version: '3'
						services:
							foliant:
								build: .
								volumes:
									- .:/usr/src/app
								working_dir: /usr/src/app
						```

						```bash
						docker-compose run --rm foliant make docx
						```
						<aside class="notes">
							Аналогично примеру с компиляцией
						</aside>
					</textarea>
				</section>
				<section>
					<h3>Выводы</h3>
					<h4 class="fragment">Изучайте docker</h4>
					<ul>
						<li class="fragment">Docker - просто начать</li>
						<li class="fragment">Docker - большие возможности</li>
						<li class="fragment">
							<span>Docker ведет к прокачке ваших навыков</span><br />
							<span class="fragment">и повышению зарплаты :)</span>
						</li>
					</ul>
				</section>
				<section class="slogan">
					<div>
						<p>Resume driven</p><p>development</p>
						<p class="fragment bright">completed!</p>
					</div>
				</section>
				<section class="thanks" data-background="/images/friends.png" data-background-size="600px">
					<div>
						<div class="fll">
							<h3>Спасибо!</h3>
							<h3>Вопросы?</h3>
							<p>Андрей Копылов</p>
							<p>aa74ko@gmail.com</p>
						</div>
						<div class="flr">
							<img data-src="/images/qrcode.png" width=300>
						</div>
					</div>
					<div class="clear">
						<p>https://github.com/aak74/docker-driven-development</p>
						<br />
						<strong>
							<p>Мы нанимаем:</p>
						</strong>
						<p>job@arealidea.ru</p>
					</div>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
				]
			});
			Reveal.configure({ slideNumber: true });
		</script>
	</body>
</html>
