# Установка серверного ПО

## Образ и контейнер
__Образ__ - это слепок файловой системы.

__Контейнер__ - это живой образ.

Можно сделать и обратный вывод:
Образ - это мертвый контейнер. Как только в контейнере завершается последний процесс - контейнер умирает.

## Распространение образов
Практически все производители ПО имеют официальные образы, распространяемые через [Docker Hub](https://hub.docker.com/).
Для установки ПО достаточно загрузить образ из [Docker Hub](https://hub.docker.com/). Или из собственного Docker registry.
Установка ПО никогда еще не была настолько легкой.
Образ можно модифицировать и сохранять локально или в Docker registry.

## Запуск контейнера (docker run)
Созданный образ можно запустить. Причем типичное время запуска контейнера - 1 секунда.
Виртуальная машина может запускаться минуту и более.

Запустить контейнер очень легко:
```docker run -d mongo```
Такого рода команда бесполезна так, как наружу не выставлены порты.
```docker run -d -p 27017:27017 mongo```
Теперь к MongoDB можно обратиться по указанному порту.
Если вам нужно запустить другой инстанс MongoDB для другого проекта, то необходимо поменять внешний порт. 
```docker run -d -p 37017:27017 mongo```. 
Если внешние для контейнера порты будут одинаковыми, то возникнет конфликт портов на локальной машине.
Теперь с базой данных можно работать. Данные сохраняются внутри файловой системы контейнера. Однако, все изменения, произошедшие в файловой системе контейнера, после его остановки исчезают. Контейнеры по своей природе stateless, то есть не сохраняют состояние. У этого есть огромные плюсы, о которых мы поговорим чуть позже.

Для сохранения данных необходимо использовать внешние для контейнера тома.
`docker run -d -p 27017:27017 --volume=./data/mongo:/db/data mongo`
Кроме того внешние тома можно использовать для чтения. Например внутрь контейнера можно прокинуть такие файлы как `/etc/passwd` и `/etc/group`. После этого внутри контейнера у вас окажется тот же набор пользователей и групп, что и на хост машине.


## Dockerfile
Вместо использования готовых образов можно подготовить свой образ.
Делается это с помощью файла Dockerfile.

```dockerfile=
FROM mongo:3-jessie

COPY ./mongo.conf /usr/local/etc/mongo/mongo.conf
EXPOSE 27017

CMD ["mongod"]
```
В этом примере мы заменили стандартный конфиг на свой.

## Запуск набора контейнеров (docker-compose)
Параметров для запуска может быть довольно много и указывать их все может быть весьма утомительно.
Чтобы избежать этого можно воспользоваться docker-compose. Эта утилита позволяет запускать один или более контейнеров с параметрами указанными в файле docker-compose.yml
Построение образов и запуск контейнеров: `docker-compose up --build -d`
Построение образа может занять некоторое время. Запуск же очень быстрый. Перестройка образа может понадобиться только в случае изменения параметров или файлов, которые копируются внутрь образа.

### Пример docker-compose.yml

```dockerfile=
version: '2'

services:
  mongo:
    image: mongo:3-jessie
    container_name: mongodb
    volumes:
      - ./data/mongo:/data/db
    networks:
      - skynet
    restart: always
    entrypoint:
      mongod
      
networks:
  skynet:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 10.1.0.1/24
```

### Запуск сервиса внутри контейнера (docker-compose run)
```docker-compose run service-name```
По имени сервиса находит образ, указанный в файле docker-compose.yml и  запускает контейнер, с параметрами из того же файла. Из параметров не применяются только порты, которые выставляются наружу контейнера. Такое поведение необходимо во избегание коллизий с портами. Однако если же вы хотите выставлять наружу те же порты, которые указаны в docker-compose.yml достаточно указать параметр `--service-ports`.
