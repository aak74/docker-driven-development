# Установка серверного ПО

## Образ и контейнер
Терминология не является официальной.
__Образ__ - это слепок файловой системы.

__Контейнер__ - это оживший образ.

Можно сделать и обратный вывод:
Образ - это мертвый контейнер. Как только в контейнере завершается последний процесс - контейнер умирает.

## Распространение образов
Практически все производители ПО имеют официальные образы, распространяемые через [Docker Hub](https://hub.docker.com/).
Для установки ПО достаточно загрузить образ из [Docker Hub](https://hub.docker.com/). Или из собственного Docker registry.
__Установка ПО никогда еще не была настолько легкой__.
Образ можно модифицировать и сохранять локально или в Docker registry.

## Запуск контейнера (docker run)
Созданный образ можно запустить. Причем типичное время запуска контейнера - 1 секунда и менее.
Виртуальная машина может запускаться минуту и более.

Запустить контейнер очень легко:
```docker run -d mongo```
Если вы ранее не скачивали образ, то он скачается  автоматически.
Правда воспользоваться прелестной MongoDB не получится, потому что наружу не выставлены порты.

### Порты
Для исправления ситуации воспользуемся командой:
```docker run -d -p 27017:27017 mongo```
Теперь к MongoDB можно обратиться по порту `27017`.

Если вам одновременно нужно запустить более одного инстанса MongoDB, то необходимо поменять внешний порт. 
```docker run -d -p 37017:27017 mongo```. 

Если внешние для контейнера порты будут одинаковыми, то возникнет конфликт портов на локальной машине.

Теперь с базой данных можно работать. Данные сохраняются внутри файловой системы контейнера. Однако, все изменения, произошедшие в файловой системе контейнера, после его остановки исчезают. __Контейнеры по своей природе stateless, то есть не сохраняют состояние__. У этого есть огромные плюсы, о которых мы поговорим чуть позже.

### Тома
Для сохранения данных необходимо использовать внешние для контейнера тома.
`docker run -d -p 27017:27017 --volume=./data/mongo:/db/data mongo`
Кроме того внешние тома можно использовать для чтения. Например внутрь контейнера можно прокинуть такие файлы как `/etc/passwd` и `/etc/group`. После этого внутри контейнера у вас окажется тот же набор пользователей и групп, что и на хост машине.


## Dockerfile
Часто готовых образов недостаточно для комфортного использования.
Вместо использования готовых образов можно подготовить свой образ.
Делается это с помощью файла Dockerfile.

```dockerfile
FROM mongo:3-jessie

COPY ./mongo.conf /usr/local/etc/mongo/mongo.conf
EXPOSE 27017

CMD ["mongod"]
```
В этом примере мы заменили стандартный конфиг на свой.

## docker-compose
Параметров для запуска может быть довольно много и указывать их все может быть весьма утомительно.
Чтобы избежать этого можно воспользоваться docker-compose. Эта утилита позволяет запускать один или более контейнеров с параметрами указанными в файле `docker-compose.yml`.
Построение образов и запуск контейнеров: `docker-compose up --build -d`
Построение образа может занять некоторое время. Запуск же очень быстрый. Перестройка образа может понадобиться только в случае изменения параметров или файлов, которые копируются внутрь образа.

### Запуск набора контейнеров
При необходимости в `docker-compose.yml` можно поместить описание нескольких сервисов.
После запуска контейнеров командой `docker-compose up --build -d` вы получите набор запущенных контейнеров, которые работают в одной виртуальной сети.

### Пример docker-compose.yml

```yml
version: '2'

services:
  mongo:
    image: mongo:3-jessie
    container_name: mongodb
    volumes:
      - ./data/mongo:/data/db
    networks:
      - skynet
    restart: always
    entrypoint:
      mongod
      
networks:
  skynet:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 10.1.0.1/24
```

### Запуск сервиса внутри контейнера (docker-compose run)
Бывает удобно запускать ПО прям из контейнера.

Делается это так:
```docker-compose run service-name```
По имени сервиса находит сервис, указанный в файле docker-compose.yml и  запускает контейнер, с параметрами из того же файла. Из параметров не применяются только порты, даже если они и указаны в файле `docker-compose.yml`. Такое поведение необходимо во избежание коллизий с портами. Однако если же вы хотите выставлять наружу те же порты, которые указаны в `docker-compose.yml` достаточно указать параметр `--service-ports`.
